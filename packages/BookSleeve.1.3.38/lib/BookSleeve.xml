<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BookSleeve</name>
    </assembly>
    <members>
        <member name="T:BookSleeve.ClientInfo">
            <summary>
            Represents the state of an individual client connection to redis
            </summary>
        </member>
        <member name="M:BookSleeve.ClientInfo.ToString">
            <summary>
            Format the object as a string
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.Address">
            <summary>
            address/port of the client
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.AgeSeconds">
            <summary>
            total duration of the connection in seconds
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.IdleSeconds">
            <summary>
            idle time of the connection in seconds
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.Database">
            <summary>
            current database ID
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.SubscriptionCount">
            <summary>
            number of channel subscriptions
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.PatternSubscriptionCount">
            <summary>
            number of pattern matching subscriptions
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.TransactionCommandLength">
            <summary>
            number of commands in a MULTI/EXEC context
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.FlagsRaw">
            <summary>
            The client flags can be a combination of:
            O: the client is a slave in MONITOR mode
            S: the client is a normal slave server
            M: the client is a master
            x: the client is in a MULTI/EXEC context
            b: the client is waiting in a blocking operation
            i: the client is waiting for a VM I/O (deprecated)
            d: a watched keys has been modified - EXEC will fail
            c: connection to be closed after writing entire reply
            u: the client is unblocked
            A: connection to be closed ASAP
            N: no specific flag set
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.Flags">
            <summary>
            The flags associated with this connection
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.LastCommand">
            <summary>
             last command played
            </summary>
        </member>
        <member name="P:BookSleeve.ClientInfo.Name">
            <summary>
            The name allocated to this connection, if any
            </summary>
        </member>
        <member name="T:BookSleeve.ClientFlags">
            <summary>
            The client flags can be a combination of:
            O: the client is a slave in MONITOR mode
            S: the client is a normal slave server
            M: the client is a master
            x: the client is in a MULTI/EXEC context
            b: the client is waiting in a blocking operation
            i: the client is waiting for a VM I/O (deprecated)
            d: a watched keys has been modified - EXEC will fail
            c: connection to be closed after writing entire reply
            u: the client is unblocked
            A: connection to be closed ASAP
            N: no specific flag set
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.None">
            <summary>
            no specific flag set
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.SlaveMonitor">
            <summary>
            the client is a slave in MONITOR mode
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Slave">
            <summary>
            the client is a normal slave server
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Master">
            <summary>
            the client is a master
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Transaction">
            <summary>
            the client is in a MULTI/EXEC context
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Blocked">
            <summary>
            the client is waiting in a blocking operation
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.TransactionDoomed">
            <summary>
            a watched keys has been modified - EXEC will fail
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Closing">
            <summary>
            connection to be closed after writing entire reply
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.Unblocked">
            <summary>
            the client is unblocked
            </summary>
        </member>
        <member name="F:BookSleeve.ClientFlags.CloseASAP">
            <summary>
            connection to be closed ASAP
            </summary>
        </member>
        <member name="T:BookSleeve.Condition">
            <summary>
            Describes a pre-condition used in a redis transaction
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyExists(System.Int32,System.String)">
            <summary>
            Enforces that the given key must exist
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyNotExists(System.Int32,System.String)">
            <summary>
            Enforces that the given key must not exist
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldExists(System.Int32,System.String,System.String)">
            <summary>
            Enforces that the given hash-field must exist
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldNotExists(System.Int32,System.String,System.String)">
            <summary>
            Enforces that the given hash-field must not exist
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyEquals(System.Int32,System.String,System.String)">
            <summary>
            Enforces that the given key must have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyEquals(System.Int32,System.String,System.Nullable{System.Int64})">
            <summary>
            Enforces that the given key must have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyNotEquals(System.Int32,System.String,System.String)">
            <summary>
            Enforces that the given key must not have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.KeyNotEquals(System.Int32,System.String,System.Nullable{System.Int64})">
            <summary>
            Enforces that the given key must not have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldEquals(System.Int32,System.String,System.String,System.String)">
            <summary>
            Enforces that the given hash-field must have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldEquals(System.Int32,System.String,System.String,System.Nullable{System.Int64})">
            <summary>
            Enforces that the given hash-field must have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldNotEquals(System.Int32,System.String,System.String,System.String)">
            <summary>
            Enforces that the given hash-field must not have the specified value
            </summary>
        </member>
        <member name="M:BookSleeve.Condition.HashFieldNotEquals(System.Int32,System.String,System.String,System.Nullable{System.Int64})">
            <summary>
            Enforces that the given hash-field must not have the specified value
            </summary>
        </member>
        <member name="T:BookSleeve.ConnectionUtils">
            <summary>
            Provides utility methods for managing connections to multiple (master/slave) redis servers (with the same
            information - not sharding).
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.SelectConfiguration(System.String,System.String[]@,System.IO.TextWriter)">
            <summary>
            Inspect the provided configration, and connect to the available servers to report which server is the preferred/active node.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.SelectConfiguration(System.String,System.String[]@,System.String,System.IO.TextWriter)">
            <summary>
            Inspect the provided configration, and connect to the available servers to report which server is the preferred/active node.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.Connect(System.String,System.IO.TextWriter)">
            <summary>
            Inspect the provided configration, and connect to the preferred/active node after checking what nodes are available.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.Connect(System.String,System.Boolean,System.String,System.IO.TextWriter)">
            <summary>
            Inspect the provided configration, and connect to the preferred/active node after checking what nodes are available.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.SubscribeToMasterSwitch(BookSleeve.RedisSubscriberConnection,System.Action{System.String})">
            <summary>
            Subscribe to perform some operation when a change to the preferred/active node is broadcast.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.SwitchMaster(System.String,System.String,System.IO.TextWriter)">
            <summary>
            Using the configuration available, and after checking which nodes are available, switch the master node and broadcast this change.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.SwitchMaster(System.String,System.String,System.String,System.IO.TextWriter)">
            <summary>
            Using the configuration available, and after checking which nodes are available, switch the master node and broadcast this change.
            </summary>
        </member>
        <member name="M:BookSleeve.ConnectionUtils.BroadcastReconnectMessage(BookSleeve.RedisConnection)">
            <summary>
            Prompt all clients to reconnect.
            </summary>
        </member>
        <member name="T:BookSleeve.RedisConnection">
            <summary>
            A thread-safe, multiplexed connection to a Redis server; each connection
            should be cached and re-used (without synchronization) from multiple
            callers for maximum efficiency. Usually only a single RedisConnection
            is required
            </summary>
        </member>
        <member name="T:BookSleeve.RedisConnectionBase">
            <summary>
            Base class for a redis-connection; provides core redis services
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.DefaultSyncTimeout">
            <summary>
            The default time to wait for individual commands to complete when using Wait
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.SetServerVersion(System.Version,BookSleeve.ServerType)">
            <summary>
            Explicitly specify the server version; this is useful when INFO is not available
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetCounterValues(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Obtains fresh statistics on the usage of the connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.PingImpl(System.Boolean,System.Boolean,System.Object)">
            <summary>
            Issues a basic ping/pong pair against the server, returning the latency
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.Dispose">
            <summary>
            Releases any resources associated with the connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnDispose">
            <summary>
            Releases any resources associated with the connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnOpened">
            <summary>
            Called after opening a connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnOpening">
            <summary>
            Called before opening a connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnInitConnection">
            <summary>
            Called during connection init, but after the AUTH is sent (if needed)
            </summary>
            <returns>Whether to release any queued messages</returns>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.AlwaysTrue">
            <summary>
            An already-completed task that indicates success
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.Open">
            <summary>
            Attempts to open the connection to the remote server
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.ReleaseHeldMessages">
            <summary>
            Releases the queue of any messages "sent" before the connection was open
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnHandshakeComplete(System.Boolean)">
            <summary>
            Invoked when we have completed the handshake
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.TrySetName(System.Boolean,System.Boolean,System.Object)">
            <summary>
            Specify a name for the current connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetInfo(System.Boolean)">
            <summary>
            The INFO command returns information and statistics about the server in format that is simple to parse by computers and easy to red by humans.
            </summary>
            <remarks>http://redis.io/commands/info</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetInfo(System.String,System.Boolean)">
            <summary>
            The INFO command returns information and statistics about the server in format that is simple to parse by computers and easy to red by humans.
            </summary>
            <remarks>http://redis.io/commands/info</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.CloseAsync(System.Boolean)">
            <summary>
            Closes the connection; either draining the unsent queue (to completion), or abandoning the unsent queue.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.Close(System.Boolean)">
            <summary>
            Closes the connection; either draining the unsent queue (to completion), or abandoning the unsent queue.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.PeekSent(System.Boolean)">
            <summary>
            Peek at the next item in the sent-queue
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.ShuttingDown(System.Exception)">
            <summary>
            Invoked when the server is terminating
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetDbUsage">
            <summary>
            Indicates the number of commands executed on a per-database basis
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnError(System.Object,BookSleeve.ErrorEventArgs)">
            <summary>
            Raises an error event
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.OnError(System.String,System.Exception,System.Boolean)">
            <summary>
            Raises an error event
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetSentCount">
            <summary>
            Return the number of items in the sent-queue
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.SuspendFlush">
            <summary>
            Temporarily suspends eager-flushing (flushing if the write-queue becomes empty briefly). Buffer-based flushing
            will still occur when the data is full. This is useful if you are performing a large number of
            operations in close duration, and want to avoid packet fragmentation. Note that you MUST call
            ResumeFlush at the end of the operation - preferably using Try/Finally so that flushing is resumed
            even upon error. This method is thread-safe; any number of callers can suspend/resume flushing
            concurrently - eager flushing will resume fully when all callers have called ResumeFlush.
            </summary>
            <remarks>Note that some operations (transaction conditions, etc) require flushing - this will still
            occur even if the buffer is only part full.</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.ResumeFlush">
            <summary>
            Resume eager-flushing (flushing if the write-queue becomes empty briefly). See SuspendFlush for
            full usage.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.EnqueueMessages(BookSleeve.RedisMessage[],System.Boolean)">
            <summary>
            Writes a group of messages, but allowing other threads to inject messages between them;
            this method minimises the numbers of packets by preventing flush until all are written
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetCannotSendMessage">
            <summary>
            The message to supply to callers when rejecting messages
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.Wait``1(System.Threading.Tasks.Task{``0})">
            <summary>
            If the task is not yet completed, blocks the caller until completion up to a maximum of SyncTimeout milliseconds.
            Once a task is completed, the result is returned.
            </summary>
            <param name="task">The task to wait on</param>
            <returns>The return value of the task.</returns>
            <exception cref="T:System.TimeoutException">If SyncTimeout milliseconds is exceeded.</exception>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.Wait(System.Threading.Tasks.Task)">
            <summary>
            If the task is not yet completed, blocks the caller until completion up to a maximum of SyncTimeout milliseconds.
            </summary>
            <param name="task">The task to wait on</param>
            <exception cref="T:System.TimeoutException">If SyncTimeout milliseconds is exceeded.</exception>
            <remarks>If an exception is throw, it is extracted from the AggregateException (unless multiple exceptions are found)</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.GetTimeoutSummary">
            <summary>
            Give some information about the oldest incomplete (but sent) message on the server
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.WaitAll(System.Threading.Tasks.Task[])">
            <summary>
            Waits for all of a set of tasks to complete, up to a maximum of SyncTimeout milliseconds.
            </summary>
            <param name="tasks">The tasks to wait on</param>
            <exception cref="T:System.TimeoutException">If SyncTimeout milliseconds is exceeded.</exception>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.WaitAny(System.Threading.Tasks.Task[])">
            <summary>
            Waits for any of a set of tasks to complete, up to a maximum of SyncTimeout milliseconds.
            </summary>
            <param name="tasks">The tasks to wait on</param>
            <returns>The index of a completed task</returns>
            <exception cref="T:System.TimeoutException">If SyncTimeout milliseconds is exceeded.</exception>        
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}})">
            <summary>
            Add a continuation (a callback), to be executed once a task has completed
            </summary>
            <param name="task">The task to add a continuation to</param>
            <param name="action">The continuation to perform once completed</param>
            <returns>A new task representing the composed operation</returns>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task})">
            <summary>
            Add a continuation (a callback), to be executed once a task has completed
            </summary>
            <param name="task">The task to add a continuation to</param>
            <param name="action">The continuation to perform once completed</param>
            <returns>A new task representing the composed operation</returns>
        </member>
        <member name="M:BookSleeve.RedisConnectionBase.EnableSyncCallbacks">
            <summary>
            Attempt to reduce Task overhead by completing tasks without continuations synchronously (default is asynchronously)
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.SyncTimeout">
            <summary>
            The amount of time to wait for any individual command to return a result when using Wait
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.Host">
            <summary>
            The host for the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.Password">
            <summary>
            The password used to authenticate with the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.Port">
            <summary>
            The port for the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.IOTimeout">
            <summary>
            The IO timeout to use when communicating with the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.Features">
            <summary>
            Features available to the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.Name">
            <summary>
            Specify a name for this connection (displayed via Server.ListClients / CLIENT LIST)
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.ServerVersion">
            <summary>
            The version of the connected redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.State">
            <summary>
            The current state of the connection
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.OutstandingCount">
            <summary>
            Indicate the number of messages that have not yet been set.
            </summary>
        </member>
        <member name="E:BookSleeve.RedisConnectionBase.Closed">
            <summary>
            Raised when a connection becomes closed.
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.ShutdownType">
            <summary>
            If the connection has been shut down, what was the reason?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.QuitOnClose">
            <summary>
            Should a QUIT be sent when closing the connection?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.KeepAliveSeconds">
            <summary>
            How frequently should keep-alives be sent?
            </summary>
        </member>
        <member name="E:BookSleeve.RedisConnectionBase.Shutdown">
            <summary>
            Invoked when the server is shutting down; includes any error information
            </summary>
        </member>
        <member name="E:BookSleeve.RedisConnectionBase.Error">
            <summary>
            Invoked when any error message is received on the connection.
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.IncludeDetailInTimeouts">
            <summary>
            If true, then when using the Wait methods, information about the oldest outstanding message
            is included in the exception; this often points to a particular operation that was monopolising
            the connection
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.ServerType">
            <summary>
            What type of connection is this
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.CompletionMode">
            <summary>
            Gets or sets the behavior for processing incoming messages.
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnectionBase.DefaultCompletionMode">
            <summary>
            Gets or sets the default CompletionMode value for all new connections.
            </summary>
        </member>
        <member name="T:BookSleeve.RedisConnectionBase.ConnectionState">
            <summary>
            Indicates the current state of the connection to the server
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.Shiny">
            <summary>
            A connection that has not yet been innitialized
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.New">
            <summary>
            A connection that has not yet been innitialized
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.Opening">
            <summary>
            A connection that is in the process of opening
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.Open">
            <summary>
            An open connection
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.Closing">
            <summary>
            A connection that is in the process of closing
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnectionBase.ConnectionState.Closed">
            <summary>
            A connection that is now closed and cannot be used
            </summary>
        </member>
        <member name="T:BookSleeve.IScriptingCommands">
            <summary>
            Commands that apply to Redis scripting (Lua).
            </summary>
            <remarks>http://redis.io/commands#scripting</remarks>
        </member>
        <member name="M:BookSleeve.IScriptingCommands.Eval(System.Int32,System.String,System.String[],System.Object[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Execute a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.
            All key-names should be passed via the keyArgs parameter, which allows necessary checks by Redis. Note that Lua scripts in Redis have a range of features and
            limitations - be sure to review the documentation.
            </summary>
            <remarks>http://redis.io/commands/eval</remarks>
        </member>
        <member name="M:BookSleeve.IScriptingCommands.Prepare(System.String[])">
            <summary>
            Ensures that the given script exists
            </summary>
            <remarks>http://redis.io/commands/script-exists and http://redis.io/commands/script-load</remarks>
        </member>
        <member name="T:BookSleeve.IServerCommands">
            <summary>
            Commands related to server operation and configuration, rather than data.
            </summary>
            <remarks>http://redis.io/commands#server</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.FlushDb(System.Int32)">
            <summary>
            Delete all the keys of the currently selected DB.
            </summary>
            <remarks>http://redis.io/commands/flushdb</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.FlushAll">
            <summary>
            Delete all the keys of all the existing databases, not just the currently selected one.
            </summary>
            <remarks>http://redis.io/commands/flushall</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.Ping(System.Boolean)">
            <summary>
            This command is often used to test if a connection is still alive, or to measure latency.
            </summary>
            <returns>The latency in milliseconds.</returns>
            <remarks>http://redis.io/commands/ping</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.Time(System.Boolean)">
            <summary>
            The TIME command returns the current server time.
            </summary>
            <returns>The server's current time.</returns>
            <remarks>http://redis.io/commands/time</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.GetConfig(System.String)">
            <summary>
            Get all configuration parameters matching the specified pattern.
            </summary>
            <param name="pattern">All the configuration parameters matching this parameter are reported as a list of key-value pairs.</param>
            <returns>All matching configuration parameters.</returns>
            <remarks>http://redis.io/commands/config-get</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.SetConfig(System.String,System.String)">
            <summary>
            The CONFIG SET command is used in order to reconfigure the server at runtime without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.
            </summary>
            <remarks>http://redis.io/commands/config-set</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.MakeSlave(System.String,System.Int32)">
            <summary>
            The SLAVEOF command can change the replication settings of a slave on the fly. In the proper form SLAVEOF hostname port will make the server a slave of another server listening at the specified hostname and port.
            If a server is already a slave of some master, SLAVEOF hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.
            </summary>
            <remarks>http://redis.io/commands/slaveof</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.MakeMaster">
            <summary>
            The SLAVEOF command can change the replication settings of a slave on the fly. 
            If a Redis server is already acting as slave, the command SLAVEOF NO ONE will turn off the replication, turning the Redis server into a MASTER.
            The form SLAVEOF NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the slave into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a slave.
            </summary>
        </member>
        <member name="M:BookSleeve.IServerCommands.FlushScriptCache">
            <summary>
            Flush the Lua scripts cache; this can damage existing connections that expect the flush to behave normally, and should be used with caution.
            </summary>
            <remarks>http://redis.io/commands/script-flush</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.ListClients">
            <summary>
            The CLIENT LIST command returns information and statistics about the client connections server in a mostly human readable format.
            </summary>
            <remarks>http://redis.io/commands/client-list</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.KillClient(System.String)">
            <summary>
            The CLIENT KILL command closes a given client connection identified by ip:port.
            </summary>
            <remarks>http://redis.io/commands/client-kill</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.GetInfo(System.String,System.Boolean)">
            <summary>
            The INFO command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.
            </summary>
            <remarks>http://redis.io/commands/info</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.Export(System.Int32,System.String)">
            <summary>
            Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the RESTORE command.
            The serialization format is opaque and non-standard. The serialized value does NOT contain expire information. In order to capture the time to live of the current value the PTTL command should be used.
            </summary>
            <remarks>http://redis.io/commands/dump</remarks>
        </member>
        <member name="M:BookSleeve.IServerCommands.Import(System.Int32,System.String,System.Byte[],System.Nullable{System.Int32})">
            <summary>
            Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via Export).
            </summary>
            <remarks>http://redis.io/commands/restore</remarks>
        </member>
        <member name="T:BookSleeve.ISortedSetCommands">
            <summary>
            Commands that apply to sorted sets per key. A sorted set keeps a "score"
            per element, and this score is used to order the elements. Duplicates
            are not allowed (typically, the score of the duplicate is added to the
            pre-existing element instead).
            </summary>
            <remarks>http://redis.io/commands#sorted_set</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Add(System.Int32,System.String,System.String,System.Double,System.Boolean)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key. It is possible to specify multiple score/member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering. If key does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.
            The score values should be the string representation of a numeric value, and accepts double precision floating point numbers.
            </summary>
            <returns>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</returns>
            <remarks>http://redis.io/commands/zadd</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Add(System.Int32,System.String,System.Byte[],System.Double,System.Boolean)">
            <summary>
            Adds all the specified members with the specified scores to the sorted set stored at key. It is possible to specify multiple score/member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering. If key does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.
            The score values should be the string representation of a numeric value, and accepts double precision floating point numbers.
            </summary>
            <returns>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</returns>
            <remarks>http://redis.io/commands/zadd</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.GetLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the sorted set cardinality (number of elements) of the sorted set stored at key.
            </summary>
            <returns>the cardinality (number of elements) of the sorted set, or 0 if key does not exist.</returns>
            <remarks>http://redis.io/commands/zcard</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.GetLength(System.Int32,System.String,System.Double,System.Double,System.Boolean)">
            <summary>
            Returns the number of elements in the sorted set at key with a score between min and max.
            The min and max arguments have the same semantic as described for ZRANGEBYSCORE.
            </summary>
            <returns>the number of elements in the specified score range.</returns>
            <remarks>http://redis.io/commands/zcount</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Increment(System.Int32,System.String,System.String,System.Double,System.Boolean)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created.
            An error is returned when key exists but does not hold a sorted set.
            The score value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.
            </summary>
            <remarks>http://redis.io/commands/zincrby</remarks>
            <returns>the new score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Increment(System.Int32,System.String,System.Byte[],System.Double,System.Boolean)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created.
            An error is returned when key exists but does not hold a sorted set.
            The score value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.
            </summary>
            <remarks>http://redis.io/commands/zincrby</remarks>
            <returns>the new score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Increment(System.Int32,System.String,System.String[],System.Double,System.Boolean)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created.
            An error is returned when key exists but does not hold a sorted set.
            The score value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.
            </summary>
            <remarks>http://redis.io/commands/zincrby</remarks>
            <returns>the new score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Increment(System.Int32,System.String,System.Byte[][],System.Double,System.Boolean)">
            <summary>
            Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created.
            An error is returned when key exists but does not hold a sorted set.
            The score value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.
            </summary>
            <remarks>http://redis.io/commands/zincrby</remarks>
            <returns>the new score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Range(System.Int32,System.String,System.Int64,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.
            See ZREVRANGE when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).
            Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <remarks>http://redis.io/commands/zrange</remarks>
            <remarks>http://redis.io/commands/zrevrange</remarks>
            <returns>list of elements in the specified range (optionally with their scores).</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.RangeString(System.Int32,System.String,System.Int64,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.
            See ZREVRANGE when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).
            Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <remarks>http://redis.io/commands/zrange</remarks>
            <remarks>http://redis.io/commands/zrevrange</remarks>
            <returns>list of elements in the specified range (optionally with their scores).</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.RangeString(System.Int32,System.String,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Returns the specified range of elements in the sorted set stored at key. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.
            See ZREVRANGE when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).
            Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and so on.
            </summary>
            <remarks>http://redis.io/commands/zrange</remarks>
            <remarks>http://redis.io/commands/zrevrange</remarks>
            <returns>list of elements in the specified range (optionally with their scores).</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Range(System.Int32,System.String,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Returns all the elements in the sorted set at key with a score between min and max (including elements with score equal to min or max). The elements are considered to be ordered from low to high scores.
            The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).
            The optional LIMIT argument can be used to only get a range of the matching elements (similar to SELECT LIMIT offset, count in SQL). Keep in mind that if offset is large, the sorted set needs to be traversed for offset elements before getting to the elements to return, which can add up to O(N) time complexity.
            </summary>
            <remarks>http://redis.io/commands/zrangebyscore</remarks>
            <remarks>http://redis.io/commands/zrevrangebyscore</remarks>
            <returns>list of elements in the specified score range (optionally with their scores).</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Rank(System.Int32,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns the rank of member in the sorted set stored at key, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank 0.
            </summary>
            <remarks>http://redis.io/commands/zrank</remarks>
            <remarks>http://redis.io/commands/zrevrank</remarks>
            <returns>If member exists in the sorted set, Integer reply: the rank of member. If member does not exist in the sorted set or key does not exist, Bulk reply: nil.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Rank(System.Int32,System.String,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Returns the rank of member in the sorted set stored at key, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank 0.
            </summary>
            <remarks>http://redis.io/commands/zrank</remarks>
            <remarks>http://redis.io/commands/zrevrank</remarks>
            <returns>If member exists in the sorted set, Integer reply: the rank of member. If member does not exist in the sorted set or key does not exist, Bulk reply: nil.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Score(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the score of member in the sorted set at key. If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <remarks>http://redis.io/commands/zscore</remarks>
            <returns>the score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Score(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Returns the score of member in the sorted set at key. If member does not exist in the sorted set, or key does not exist, nil is returned.
            </summary>
            <remarks>http://redis.io/commands/zscore</remarks>
            <returns>the score of member (a double precision floating point number), represented as string.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Remove(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Removes the specified members from the sorted set stored at key. Non existing members are ignored.
            An error is returned when key exists and does not hold a sorted set.
            </summary>
            <remarks>http://redis.io/commands/zrem</remarks>
            <returns>The number of members removed from the sorted set, not including non existing members.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Remove(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Removes the specified members from the sorted set stored at key. Non existing members are ignored.
            An error is returned when key exists and does not hold a sorted set.
            </summary>
            <remarks>http://redis.io/commands/zrem</remarks>
            <returns>The number of members removed from the sorted set, not including non existing members.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Remove(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Removes the specified members from the sorted set stored at key. Non existing members are ignored.
            An error is returned when key exists and does not hold a sorted set.
            </summary>
            <remarks>http://redis.io/commands/zrem</remarks>
            <returns>The number of members removed from the sorted set, not including non existing members.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.Remove(System.Int32,System.String,System.Byte[][],System.Boolean)">
            <summary>
            Removes the specified members from the sorted set stored at key. Non existing members are ignored.
            An error is returned when key exists and does not hold a sorted set.
            </summary>
            <remarks>http://redis.io/commands/zrem</remarks>
            <returns>The number of members removed from the sorted set, not including non existing members.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.RemoveRange(System.Int32,System.String,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Removes all elements in the sorted set stored at key with rank between start and stop. Both start and stop are 0-based indexes with 0 being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: -1 is the element with the highest score, -2 the element with the second highest score and so forth.
            </summary>
            <remarks>http://redis.io/commands/zremrangebyrank</remarks>
            <returns>the number of elements removed.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.RemoveRange(System.Int32,System.String,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Removes all elements in the sorted set stored at key with a score between min and max (inclusive).
            </summary>
            <remarks>http://redis.io/commands/zremrangebyscore</remarks>
            <returns>the number of elements removed.</returns>
            <remarks>Since version 2.1.6, min and max can be exclusive, following the syntax of ZRANGEBYSCORE.</remarks>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.IntersectAndStore(System.Int32,System.String,System.String[],BookSleeve.RedisAggregate,System.Boolean)">
            <summary>
            Computes the intersection of numkeys sorted sets given by the specified keys, and stores the result in destination.
            </summary>
            <remarks>http://redis.io/commands/zinterstore</remarks>
            <returns>the number of elements in the resulting set.</returns>
        </member>
        <member name="M:BookSleeve.ISortedSetCommands.UnionAndStore(System.Int32,System.String,System.String[],BookSleeve.RedisAggregate,System.Boolean)">
            <summary>
            Computes the union of numkeys sorted sets given by the specified keys, and stores the result in destination. It is mandatory to provide the number of input keys (numkeys) before passing the input keys and the other (optional) arguments.
            </summary>
            <remarks>http://redis.io/commands/zunionstore</remarks>
            <returns>the number of elements in the resulting set.</returns>
        </member>
        <member name="T:BookSleeve.ISetCommands">
            <summary>
            Commands that apply to sets of items per key; sets
            have no defined order and are strictly unique. Duplicates
            are not allowed (typically, duplicates are silently discarded).
            </summary>
            <remarks>http://redis.io/commands#set</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Add(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Add member to the set stored at key. If member is already a member of this set, no operation is performed. If key does not exist, a new set is created with member as its sole member.
            </summary>
            <returns>true if added</returns>
            <remarks>http://redis.io/commands/sadd</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Add(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Add member to the set stored at key. If member is already a member of this set, no operation is performed. If key does not exist, a new set is created with member as its sole member.
            </summary>
            <returns>true if added</returns>
            <remarks>http://redis.io/commands/sadd</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Add(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Add member to the set stored at key. If member is already a member of this set, no operation is performed. If key does not exist, a new set is created with member as its sole member.
            </summary>
            <returns>the number of elements actually added to the set.</returns>
            <remarks>http://redis.io/commands/sadd</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Add(System.Int32,System.String,System.Byte[][],System.Boolean)">
            <summary>
            Add member to the set stored at key. If member is already a member of this set, no operation is performed. If key does not exist, a new set is created with member as its sole member.
            </summary>
            <returns>the number of elements actually added to the set.</returns>
            <remarks>http://redis.io/commands/sadd</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the set cardinality (number of elements) of the set stored at key.
            </summary>
            <returns>the cardinality (number of elements) of the set, or 0 if key does not exist.</returns>
            <remarks>http://redis.io/commands/scard</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.DifferenceString(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the difference between the first set and all the successive sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sdiff</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Difference(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the difference between the first set and all the successive sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sdiff</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.DifferenceAndStore(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            This command is equal to SDIFF, but instead of returning the resulting set, it is stored in destination.
            </summary>
            <remarks> If destination already exists, it is overwritten.</remarks>
            <returns>the number of elements in the resulting set.</returns>
            <remarks>http://redis.io/commands/sdiffstore</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.IntersectString(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the intersection of all the given sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sinter</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Intersect(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the intersection of all the given sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sinter</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.IntersectAndStore(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            This command is equal to SINTER, but instead of returning the resulting set, it is stored in destination.
            </summary>
            <remarks>If destination already exists, it is overwritten.</remarks>
            <returns>the number of elements in the resulting set.</returns>
            <remarks>http://redis.io/commands/sinterstore</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.UnionString(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the union of all the given sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sunion</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Union(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the members of the set resulting from the union of all the given sets.
            </summary>
            <returns>list with members of the resulting set.</returns>
            <remarks>http://redis.io/commands/sunion</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.UnionAndStore(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            This command is equal to SUNION, but instead of returning the resulting set, it is stored in destination.
            </summary>
            <remarks>If destination already exists, it is overwritten.</remarks>
            <returns>the number of elements in the resulting set.</returns>
            <remarks>http://redis.io/commands/sunionstore</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Contains(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns if member is a member of the set stored at key.
            </summary>
            <returns>1 if the element is a member of the set. 0 if the element is not a member of the set, or if key does not exist.</returns>
            <remarks>http://redis.io/commands/sismember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Contains(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Returns if member is a member of the set stored at key.
            </summary>
            <returns>1 if the element is a member of the set. 0 if the element is not a member of the set, or if key does not exist.</returns>
            <remarks>http://redis.io/commands/sismember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetAllString(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all the members of the set value stored at key.
            </summary>
            <returns>all elements of the set.</returns>
            <remarks>http://redis.io/commands/smembers</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetAll(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all the members of the set value stored at key.
            </summary>
            <returns>all elements of the set.</returns>
            <remarks>http://redis.io/commands/smembers</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Move(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Move member from the set at source to the set at destination. This operation is atomic. In every given moment the element will appear to be a member of source or destination for other clients.
            </summary>
            <remarks>If the source set does not exist or does not contain the specified element, no operation is performed and 0 is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</remarks>
            <returns>1 if the element is moved. 0 if the element is not a member of source and no operation was performed.</returns>
            <remarks>http://redis.io/commands/smove</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Move(System.Int32,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Move member from the set at source to the set at destination. This operation is atomic. In every given moment the element will appear to be a member of source or destination for other clients.
            </summary>
            <remarks>If the source set does not exist or does not contain the specified element, no operation is performed and 0 is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</remarks>
            <returns>1 if the element is moved. 0 if the element is not a member of source and no operation was performed.</returns>
            <remarks>http://redis.io/commands/smove</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.RemoveRandomString(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns a random element from the set value stored at key.
            </summary>
            <returns>the removed element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/spop</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.RemoveRandom(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns a random element from the set value stored at key.
            </summary>
            <returns>the removed element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/spop</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetRandomString(System.Int32,System.String,System.Boolean)">
            <summary>
            Return a random element from the set value stored at key.
            </summary>
            <returns>the randomly selected element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/srandmember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetRandom(System.Int32,System.String,System.Boolean)">
            <summary>
            Return a random element from the set value stored at key.
            </summary>
            <returns>the randomly selected element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/srandmember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetRandomString(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Return an array of count distinct elements if count is positive. If called with a negative count the behavior changes and the command is allowed to return the same element multiple times. In this case the numer of returned elements is the absolute value of the specified count.
            </summary>
            <returns>the randomly selected element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/srandmember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.GetRandom(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Return an array of count distinct elements if count is positive. If called with a negative count the behavior changes and the command is allowed to return the same element multiple times. In this case the numer of returned elements is the absolute value of the specified count.
            </summary>
            <returns>the randomly selected element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/srandmember</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Remove(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Remove member from the set stored at key. If member is not a member of this set, no operation is performed.
            </summary>
            <returns>1 if the element was removed. 0 if the element was not a member of the set.</returns>
            <remarks>http://redis.io/commands/srem</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Remove(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Remove member from the set stored at key. If member is not a member of this set, no operation is performed.
            </summary>
            <returns>1 if the element was removed. 0 if the element was not a member of the set.</returns>
            <remarks>http://redis.io/commands/srem</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Remove(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Remove member from the set stored at key. If member is not a member of this set, no operation is performed.
            </summary>
            <returns>1 if the element was removed. 0 if the element was not a member of the set.</returns>
            <remarks>http://redis.io/commands/srem</remarks>
        </member>
        <member name="M:BookSleeve.ISetCommands.Remove(System.Int32,System.String,System.Byte[][],System.Boolean)">
            <summary>
            Remove member from the set stored at key. If member is not a member of this set, no operation is performed.
            </summary>
            <returns>1 if the element was removed. 0 if the element was not a member of the set.</returns>
            <remarks>http://redis.io/commands/srem</remarks>
        </member>
        <member name="T:BookSleeve.IKeyCommands">
            <summary>
            Generic commands that apply to all/most data structures
            </summary>
            <remarks>http://redis.io/commands#generic</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Remove(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes the specified key. A key is ignored if it does not exist.
            </summary>
            <returns>True if the key was removed.</returns>
            <remarks>http://redis.io/commands/del</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Remove(System.Int32,System.String[],System.Boolean)">
            <summary>
            Removes the specified keys. A key is ignored if it does not exist.
            </summary>
            <returns>The number of keys that were removed.</returns>
            <remarks>http://redis.io/commands/del</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Exists(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns if key exists.
            </summary>
            <returns>1 if the key exists. 0 if the key does not exist.</returns>
            <remarks>http://redis.io/commands/exists</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Expire(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Set a timeout on key. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.
            </summary>
            <remarks>If key is updated before the timeout has expired, then the timeout is removed as if the PERSIST command was invoked on key.
            For Redis versions &lt; 2.1.3, existing timeouts cannot be overwritten. So, if key already has an associated timeout, it will do nothing and return 0. Since Redis 2.1.3, you can update the timeout of a key. It is also possible to remove the timeout using the PERSIST command. See the page on key expiry for more information.</remarks>
            <returns>1 if the timeout was set. 0 if key does not exist or the timeout could not be set.</returns>
            <remarks>http://redis.io/commands/expire</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Persist(System.Int32,System.String,System.Boolean)">
            <summary>
            Remove the existing timeout on key.
            </summary>
            <returns>1 if the timeout was removed. 0 if key does not exist or does not have an associated timeout.</returns>
            <remarks>Available with 2.1.2 and above only</remarks>
            <remarks>http://redis.io/commands/persist</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Find(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all keys matching pattern.
            </summary>
            <remarks>Warning: consider KEYS as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use KEYS in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using sets.</remarks>
            <remarks>http://redis.io/commands/keys</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Move(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Move key from the currently selected database (see SELECT) to the specified destination database. When key already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use MOVE as a locking primitive because of this.
            </summary>
            <returns>1 if key was moved. 0 if key was not moved.</returns>
            <remarks>http://redis.io/commands/move</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Random(System.Int32,System.Boolean)">
            <summary>
            Return a random key from the currently selected database.
            </summary>
            <returns>the random key, or nil when the database is empty.</returns>
            <remarks>http://redis.io/commands/randomkey</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Rename(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Renames key to newkey. It returns an error when the source and destination names are the same, or when key does not exist. If newkey already exists it is overwritten.
            </summary>
            <remarks>http://redis.io/commands/rename</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.RenameIfNotExists(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Renames key to newkey if newkey does not yet exist. It returns an error under the same conditions as RENAME.
            </summary>
            <returns>1 if key was renamed to newkey. 0 if newkey already exists.</returns>
            <remarks>http://redis.io/commands/renamenx</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.TimeToLive(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the remaining time to live (seconds) of a key that has a timeout.  This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.
            </summary>
            <returns>TTL in seconds or -1 when key does not exist or does not have a timeout.</returns>
            <remarks>http://redis.io/commands/ttl</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.Type(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the string representation of the type of the value stored at key. The different types that can be returned are: string, list, set, zset and hash.
            </summary>
            <returns> type of key, or none when key does not exist.</returns>
            <remarks>http://redis.io/commands/type</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.GetLength(System.Int32,System.Boolean)">
            <summary>
            Return the number of keys in the currently selected database.
            </summary>
            <remarks>http://redis.io/commands/dbsize</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.SortString(System.Int32,System.String,System.String,System.String[],System.Int64,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns or stores the elements contained in the list, set or sorted set at key. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. 
            </summary>
            <remarks>http://redis.io/commands/sort</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.SortAndStore(System.Int32,System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns or stores the elements contained in the list, set or sorted set at key. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. 
            </summary>
            <remarks>http://redis.io/commands/sort</remarks>
        </member>
        <member name="M:BookSleeve.IKeyCommands.DebugObject(System.Int32,System.String)">
            <summary>
            Returns the raw DEBUG OBJECT output for a key; this command is not fully documented and should be avoided unless you have good reason, and then avoided anyway.
            </summary>
            <remarks>http://redis.io/commands/debug-object</remarks>
        </member>
        <member name="T:BookSleeve.IHashCommands">
            <summary>
            Commands that apply to key/sub-key/value tuples, i.e. where
            the item is a dictionary of inner values. This can be useful for
            modelling members of an entity, for example.
            </summary>
            <remarks>http://redis.io/commands#hash</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Remove(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Removes the specified fields from the hash stored at key. Non-existing fields are ignored. Non-existing keys are treated as empty hashes and this command returns 0.
            </summary>
            <remarks>http://redis.io/commands/hdel</remarks>
            <returns>The number of fields that were removed.</returns>
        </member>
        <member name="M:BookSleeve.IHashCommands.Remove(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Removes the specified fields from the hash stored at key. Non-existing fields are ignored. Non-existing keys are treated as empty hashes and this command returns 0.
            </summary>
            <remarks>http://redis.io/commands/hdel</remarks>
            <returns>The number of fields that were removed.</returns>
        </member>
        <member name="M:BookSleeve.IHashCommands.Exists(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns if field is an existing field in the hash stored at key.
            </summary>
            <returns>1 if the hash contains field. 0 if the hash does not contain field, or key does not exist.</returns>
            <remarks>http://redis.io/commands/hexists</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetString(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <returns>the value associated with field, or nil when field is not present in the hash or key does not exist.</returns>
            <remarks>http://redis.io/commands/hget</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetInt64(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <returns>the value associated with field, or nil when field is not present in the hash or key does not exist.</returns>
            <remarks>http://redis.io/commands/hget</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Get(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <returns>the value associated with field, or nil when field is not present in the hash or key does not exist.</returns>
            <remarks>http://redis.io/commands/hget</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetString(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a nil value is returned.
            </summary>
            <returns>list of values associated with the given fields, in the same order as they are requested.</returns>
            <remarks>http://redis.io/commands/hmget</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Get(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a nil value is returned.
            </summary>
            <returns>list of values associated with the given fields, in the same order as they are requested.</returns>
            <remarks>http://redis.io/commands/hmget</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetAll(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all fields and values of the hash stored at key. 
            </summary>
            <returns>list of fields and their values stored in the hash, or an empty list when key does not exist.</returns>
            <remarks>http://redis.io/commands/hgetall</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Increment(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Increments the number stored at field in the hash stored at key by increment. If key does not exist, a new key holding a hash is created. If field does not exist or holds a string that cannot be interpreted as integer, the value is set to 0 before the operation is performed.
            </summary>
            <remarks>The range of values supported by HINCRBY is limited to 64 bit signed integers.</remarks>
            <returns>the value at field after the increment operation.</returns>
            <remarks>http://redis.io/commands/hincrby</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Increment(System.Int32,System.String,System.String,System.Double,System.Boolean)">
            <summary>
            Increments the number stored at field in the hash stored at key by increment. If key does not exist, a new key holding a hash is created. If field does not exist or holds a string that cannot be interpreted as integer, the value is set to 0 before the operation is performed.
            </summary>
            <remarks>The range of values supported by HINCRBY is limited to 64 bit signed integers.</remarks>
            <returns>the value at field after the increment operation.</returns>
            <remarks>http://redis.io/commands/hincrby</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetKeys(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all field names in the hash stored at key.
            </summary>
            <returns>list of fields in the hash, or an empty list when key does not exist.</returns>
            <remarks>http://redis.io/commands/hkeys</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetValues(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all values in the hash stored at key.
            </summary>
            <returns>list of values in the hash, or an empty list when key does not exist.</returns>
            <remarks>http://redis.io/commands/hvals</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.GetLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the number of fields contained in the hash stored at key.
            </summary>
            <returns>number of fields in the hash, or 0 when key does not exist.</returns>
            <remarks>http://redis.io/commands/hlen</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Set(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and the value was updated.</returns>
            <remarks>http://redis.io/commands/hset</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Set(System.Int32,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and the value was updated.</returns>
            <remarks>http://redis.io/commands/hset</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.Set(System.Int32,System.String,System.Collections.Generic.Dictionary{System.String,System.Byte[]},System.Boolean)">
            <summary>
            Sets the specified fields to their respective values in the hash stored at key. This command overwrites any existing fields in the hash. If key does not exist, a new key holding a hash is created.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and the value was updated.</returns>
            <remarks>http://redis.io/commands/hmset</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.SetIfNotExists(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value, only if field does not yet exist. If key does not exist, a new key holding a hash is created. If field already exists, this operation has no effect.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed.</returns>
            <remarks>http://redis.io/commands/hsetnx</remarks>
        </member>
        <member name="M:BookSleeve.IHashCommands.SetIfNotExists(System.Int32,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value, only if field does not yet exist. If key does not exist, a new key holding a hash is created. If field already exists, this operation has no effect.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed.</returns>
            <remarks>http://redis.io/commands/hsetnx</remarks>
        </member>
        <member name="T:BookSleeve.IStringCommands">
            <summary>
            Commands that apply to key/value pairs, where the value
            can be a string, a BLOB, or interpreted as a number
            </summary>
            <remarks>http://redis.io/commands#string</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Append(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            If key already exists and is a string, this command appends the value at the end of the string. If key does not exist it is created and set as an empty string, so APPEND will be similar to SET in this special case.
            </summary>
            <returns>the length of the string after the append operation.</returns>
            <remarks>http://redis.io/commands/append</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Append(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            If key already exists and is a string, this command appends the value at the end of the string. If key does not exist it is created and set as an empty string, so APPEND will be similar to SET in this special case.
            </summary>
            <returns>the length of the string after the append operation.</returns>
            <remarks>http://redis.io/commands/append</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Decrement(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            Decrements the number stored at key by decrement. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that is not representable as integer. This operation is limited to 64 bit signed integers.
            </summary>
            <returns> the value of key after the increment</returns>
            <remarks>http://redis.io/commands/decrby</remarks>
            <remarks>http://redis.io/commands/decr</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Increment(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            Increments the number stored at key by increment. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that is not representable as integer. This operation is limited to 64 bit signed integers.
            </summary>
            <returns> the value of key after the increment</returns>
            <remarks>http://redis.io/commands/incrby</remarks>
            <remarks>http://redis.io/commands/incr</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Increment(System.Int32,System.String,System.Double,System.Boolean)">
            <summary>
            Increments the number stored at key by increment. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that is not representable as integer. This operation is limited to 64 bit signed integers.
            </summary>
            <returns> the value of key after the increment</returns>
            <remarks>http://redis.io/commands/incrbyfloat</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Get(System.Int32,System.String,System.Boolean)">
            <summary>
            Get the value of key. If the key does not exist the special value nil is returned. An error is returned if the value stored at key is not a string, because GET only handles string values.
            </summary>
            <returns>the value of key, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/get</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetString(System.Int32,System.String,System.Boolean)">
            <summary>
            Get the value of key. If the key does not exist the special value nil is returned. An error is returned if the value stored at key is not a string, because GET only handles string values.
            </summary>
            <returns>the value of key, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/get</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetInt64(System.Int32,System.String,System.Boolean)">
            <summary>
            Get the value of key. If the key does not exist the special value nil is returned. An error is returned if the value stored at key is not a string, because GET only handles string values.
            </summary>
            <returns>the value of key, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/get</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Get(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
            </summary>
            <remarks>Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth. The function handles out of range requests by limiting the resulting range to the actual length of the string.</remarks>
            <returns>the value of key, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/getrange</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetString(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive).
            </summary>
            <remarks>Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth. The function handles out of range requests by limiting the resulting range to the actual length of the string.</remarks>
            <returns>the value of key, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/getrange</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Get(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value nil is returned. Because of this, the operation never fails.
            </summary>
            <returns>list of values at the specified keys.</returns>
            <remarks>http://redis.io/commands/mget</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetString(System.Int32,System.String[],System.Boolean)">
            <summary>
            Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value nil is returned. Because of this, the operation never fails.
            </summary>
            <returns>list of values at the specified keys.</returns>
            <remarks>http://redis.io/commands/mget</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetSet(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Atomically sets key to value and returns the old value stored at key. Returns an error when key exists but does not hold a string value.
            </summary>
            <returns>the old value stored at key, or nil when key did not exist.</returns>
            <remarks>http://redis.io/commands/getset</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetSet(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Atomically sets key to value and returns the old value stored at key. Returns an error when key exists but does not hold a string value.
            </summary>
            <returns>the old value stored at key, or nil when key did not exist.</returns>
            <remarks>http://redis.io/commands/getset</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type.
            </summary>
            <remarks>http://redis.io/commands/set</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type.
            </summary>
            <remarks>http://redis.io/commands/set</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type.
            </summary>
            <remarks>http://redis.io/commands/set</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.String,System.Int64,System.Boolean)">
            <summary>
            Set key to hold the string value and set key to timeout after a given number of seconds.
            </summary>
            <remarks>http://redis.io/commands/setex</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.Byte[],System.Int64,System.Boolean)">
            <summary>
            Set key to hold the string value and set key to timeout after a given number of seconds.
            </summary>
            <remarks>http://redis.io/commands/setex</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.Int64,System.String,System.Boolean)">
            <summary>
            Overwrites part of the string stored at key, starting at the specified offset, for the entire length of value. If the offset is larger than the current length of the string at key, the string is padded with zero-bytes to make offset fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set value at offset.
            </summary>
            <remarks>Note that the maximum offset that you can set is 229 -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.
            Warning: When setting the last possible byte and the string value stored at key does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting byte number 536870911 (512MB allocation) takes ~300ms, setting byte number 134217728 (128MB allocation) takes ~80ms, setting bit number 33554432 (32MB allocation) takes ~30ms and setting bit number 8388608 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to SETRANGE for the same key will not have the allocation overhead.</remarks>
            <remarks>http://redis.io/commands/setrange</remarks>
            <returns>the length of the string after it was modified by the command.</returns>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.String,System.Int64,System.Byte[],System.Boolean)">
            <summary>
            Overwrites part of the string stored at key, starting at the specified offset, for the entire length of value. If the offset is larger than the current length of the string at key, the string is padded with zero-bytes to make offset fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set value at offset.
            </summary>
            <remarks>Note that the maximum offset that you can set is 229 -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.
            Warning: When setting the last possible byte and the string value stored at key does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting byte number 536870911 (512MB allocation) takes ~300ms, setting byte number 134217728 (128MB allocation) takes ~80ms, setting bit number 33554432 (32MB allocation) takes ~30ms and setting bit number 8388608 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to SETRANGE for the same key will not have the allocation overhead.</remarks>
            <remarks>http://redis.io/commands/setrange</remarks>
            <returns>the length of the string after it was modified by the command.</returns>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>
            Sets the given keys to their respective values. MSET replaces existing values with new values, just as regular SET. See MSETNX if you don't want to overwrite existing values.
            </summary>
            <remarks>MSET is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</remarks>
            <remarks>http://redis.io/commands/mset</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.Set(System.Int32,System.Collections.Generic.Dictionary{System.String,System.Byte[]},System.Boolean)">
            <summary>
            Sets the given keys to their respective values. MSET replaces existing values with new values, just as regular SET. See MSETNX if you don't want to overwrite existing values.
            </summary>
            <remarks>MSET is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</remarks>
            <remarks>http://redis.io/commands/mset</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.SetIfNotExists(System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>
            Sets the given keys to their respective values. MSETNX will not perform any operation at all even if just a single key already exists.
            </summary>
            <remarks>Because of this semantic MSETNX can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.
            MSETNX is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</remarks>
            <returns>1 if the all the keys were set, 0 if no key was set (at least one key already existed).</returns>
            <remarks>http://redis.io/commands/msetnx</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.SetIfNotExists(System.Int32,System.Collections.Generic.Dictionary{System.String,System.Byte[]},System.Boolean)">
            <summary>
            Sets the given keys to their respective values. MSETNX will not perform any operation at all even if just a single key already exists.
            </summary>
            <remarks>Because of this semantic MSETNX can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.
            MSETNX is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</remarks>
            <returns>1 if the all the keys were set, 0 if no key was set (at least one key already existed).</returns>
            <remarks>http://redis.io/commands/msetnx</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.SetIfNotExists(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed. 
            </summary>
            <returns>1 if the key was set, 0 if the key was not set</returns>
            <remarks>http://redis.io/commands/setnx</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.SetIfNotExists(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed. 
            </summary>
            <returns>1 if the key was set, 0 if the key was not set</returns>
            <remarks>http://redis.io/commands/setnx</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetBit(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            Returns the bit value at offset in the string value stored at key.
            </summary>
            <remarks>When offset is beyond the string length, the string is assumed to be a contiguous space with 0 bits. When key does not exist it is assumed to be an empty string, so offset is always out of range and the value is also assumed to be a contiguous space with 0 bits.</remarks>
            <returns>the bit value stored at offset.</returns>
            <remarks>http://redis.io/commands/getbit</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.GetLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the length of the string value stored at key. An error is returned when key holds a non-string value.
            </summary>
            <returns>the length of the string at key, or 0 when key does not exist.</returns>
            <remarks>http://redis.io/commands/strlen</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.SetBit(System.Int32,System.String,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Sets or clears the bit at offset in the string value stored at key.
            </summary>
            <remarks>The bit is either set or cleared depending on value, which can be either 0 or 1. When key does not exist, a new string value is created. The string is grown to make sure it can hold a bit at offset. The offset argument is required to be greater than or equal to 0, and smaller than 232 (this limits bitmaps to 512MB). When the string at key is grown, added bits are set to 0.
            
            Warning: When setting the last possible bit (offset equal to 232 -1) and the string value stored at key does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting bit number 232 -1 (512MB allocation) takes ~300ms, setting bit number 230 -1 (128MB allocation) takes ~80ms, setting bit number 228 -1 (32MB allocation) takes ~30ms and setting bit number 226 -1 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to SETBIT for the same key will not have the allocation overhead.
            </remarks>
            <returns>the original bit value stored at offset.</returns>
            <remarks>http://redis.io/commands/setbit</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.CountSetBits(System.Int32,System.String,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Count the number of set bits (population counting) in a string.
            By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments start and end.
            Like for the GETRANGE command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.
            </summary>
            <remarks>http://redis.io/commands/bitcount</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.BitwiseAnd(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Perform a bitwise AND operation between multiple keys (containing string values) and store the result in the destination key.
            </summary>
            <returns>The size of the string stored in the destination key, that is equal to the size of the longest input string.</returns>
            <remarks>http://redis.io/commands/bitop</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.BitwiseOr(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Perform a bitwise OR operation between multiple keys (containing string values) and store the result in the destination key.
            </summary>
            <returns>The size of the string stored in the destination key, that is equal to the size of the longest input string.</returns>
            <remarks>http://redis.io/commands/bitop</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.BitwiseXOr(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Perform a bitwise XOR operation between multiple keys (containing string values) and store the result in the destination key.
            </summary>
            <returns>The size of the string stored in the destination key, that is equal to the size of the longest input string.</returns>
            <remarks>http://redis.io/commands/bitop</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.BitwiseNot(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Perform a bitwise NOT operation on a key (containing a string value) and store the result in the destination key.
            </summary>
            <returns>The size of the string stored in the destination key, that is equal to the size of the longest input string.</returns>
            <remarks>http://redis.io/commands/bitop</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.TakeLock(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            This is a composite helper command, to help with using redis as a lock provider. This is achieved
            as a string key/value pair with timeout. If the lock does not exist (or has expired), then a new string key is
            created (with the supplied duration), and <c>true</c> is returned to indicate success. If the lock
            already exists, then no lock is taken, and <c>false</c> is returned. The value may be fetched separately, but the meaning is
            implementation-defined). No change is made if the
            lock was not successfully taken. In this case, the client should delay and retry.
            
            It is expected that a well-behaved client will also release the lock in a timely fashion via <c>ReleaseLock</c>.
            </summary>
            <returns><c>null</c> if the lock was successfully taken; the competing value otherwise</returns>
            <remarks>It transpires that robust locking in redis is actually remarkably hard, and most
            implementations are broken in one way or another (most commonly: thread-race, or extending the
            lock duration when failing to take the lock).</remarks>
        </member>
        <member name="M:BookSleeve.IStringCommands.ReleaseLock(System.Int32,System.String,System.Boolean)">
            <summary>
            Releases a lock that was taken successfully via TakeLock. You should not release a lock that you did
            not take, as this will cause problems.
            </summary>
        </member>
        <member name="T:BookSleeve.IListCommands">
            <summary>
            Commands that apply to basic lists of items per key; lists
            preserve insertion order and have no enforced uniqueness (duplicates
            are allowed)
            </summary>
            <remarks>http://redis.io/commands#list</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.InsertBefore(System.Int32,System.String,System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Inserts value in the list stored at key either before or after the reference value pivot.
            </summary>
            <remarks>When key does not exist, it is considered an empty list and no operation is performed.</remarks>
            <returns>the length of the list after the insert operation, or -1 when the value pivot was not found.</returns>
            <remarks>http://redis.io/commands/linsert</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.InsertBefore(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Inserts value in the list stored at key either before or after the reference value pivot.
            </summary>
            <remarks>When key does not exist, it is considered an empty list and no operation is performed.</remarks>
            <returns>the length of the list after the insert operation, or -1 when the value pivot was not found.</returns>
            <remarks>http://redis.io/commands/linsert</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.InsertAfter(System.Int32,System.String,System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Inserts value in the list stored at key either before or after the reference value pivot.
            </summary>
            <remarks>When key does not exist, it is considered an empty list and no operation is performed.</remarks>
            <returns>the length of the list after the insert operation, or -1 when the value pivot was not found.</returns>
            <remarks>http://redis.io/commands/linsert</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.InsertAfter(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Inserts value in the list stored at key either before or after the reference value pivot.
            </summary>
            <remarks>When key does not exist, it is considered an empty list and no operation is performed.</remarks>
            <returns>the length of the list after the insert operation, or -1 when the value pivot was not found.</returns>
            <remarks>http://redis.io/commands/linsert</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Get(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the element at index index in the list stored at key. The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.
            </summary>
            <returns>the requested element, or nil when index is out of range.</returns>
            <remarks>http://redis.io/commands/lindex</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.GetString(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the element at index index in the list stored at key. The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.
            </summary>
            <returns>the requested element, or nil when index is out of range.</returns>
            <remarks>http://redis.io/commands/lindex</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Set(System.Int32,System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Sets the list element at index to value. For more information on the index argument, see LINDEX.
            </summary>
            <remarks>An error is returned for out of range indexes.</remarks>
            <remarks>http://redis.io/commands/lset</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Set(System.Int32,System.String,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Sets the list element at index to value. For more information on the index argument, see LINDEX.
            </summary>
            <remarks>An error is returned for out of range indexes.</remarks>
            <remarks>http://redis.io/commands/lset</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.GetLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the length of the list stored at key. If key does not exist, it is interpreted as an empty list and 0 is returned. 
            </summary>
            <returns>the length of the list at key.</returns>
            <remarks>http://redis.io/commands/llen</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveFirstString(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns the first element of the list stored at key.
            </summary>
            <returns>the value of the first element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/lpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveFirst(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns the first element of the list stored at key.
            </summary>
            <returns>the value of the first element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/lpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveLastString(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns the last element of the list stored at key.
            </summary>
            <returns>the value of the first element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/rpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveLast(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes and returns the last element of the list stored at key.
            </summary>
            <returns>the value of the first element, or nil when key does not exist.</returns>
            <remarks>http://redis.io/commands/rpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveFirstString(System.Int32,System.String[],System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BLPOP is a blocking list pop primitive. It is the blocking version of LPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the head of the first list that is non-empty, with the given keys being checked in the order that they are given. A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>A null when no element could be popped and the timeout expired, otherwise the popped element.</returns>
            <remarks>http://redis.io/commands/blpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveFirst(System.Int32,System.String[],System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BLPOP is a blocking list pop primitive. It is the blocking version of LPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the head of the first list that is non-empty, with the given keys being checked in the order that they are given. A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>A null when no element could be popped and the timeout expired, otherwise the popped element.</returns>
            <remarks>http://redis.io/commands/blpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveLastString(System.Int32,System.String[],System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BRPOP is a blocking list pop primitive. It is the blocking version of RPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given. A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>A null when no element could be popped and the timeout expired, otherwise the popped element.</returns>
            <remarks>http://redis.io/commands/brpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveLast(System.Int32,System.String[],System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BRPOP is a blocking list pop primitive. It is the blocking version of RPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given. A timeout of zero can be used to block indefinitely.
            </summary>
            <returns>A null when no element could be popped and the timeout expired, otherwise the popped element.</returns>
            <remarks>http://redis.io/commands/brpop</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveLastAndAddFirst(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BRPOPLPUSH is the blocking variant of RPOPLPUSH. When source contains elements, this command behaves exactly like RPOPLPUSH. When source is empty, Redis will block the connection until another client pushes to it or until timeout is reached. A timeout of zero can be used to block indefinitely.
            </summary>
            <string>For example: consider source holding the list a,b,c, and destination holding the list x,y,z. Executing RPOPLPUSH results in source holding a,b and destination holding c,x,y,z.</string>
            <remarks>If source does not exist, the value nil is returned and no operation is performed. If source and destination are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</remarks>
            <returns>the element being popped and pushed.</returns>
            <remarks>http://redis.io/commands/brpoplpush</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.BlockingRemoveLastAndAddFirstString(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>IMPORTANT: blocking commands will interrupt multiplexing, and should not be used on a connection being used by parallel consumers.
            BRPOPLPUSH is the blocking variant of RPOPLPUSH. When source contains elements, this command behaves exactly like RPOPLPUSH. When source is empty, Redis will block the connection until another client pushes to it or until timeout is reached. A timeout of zero can be used to block indefinitely.
            </summary>
            <string>For example: consider source holding the list a,b,c, and destination holding the list x,y,z. Executing RPOPLPUSH results in source holding a,b and destination holding c,x,y,z.</string>
            <remarks>If source does not exist, the value nil is returned and no operation is performed. If source and destination are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</remarks>
            <returns>the element being popped and pushed.</returns>
            <remarks>http://redis.io/commands/brpoplpush</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.AddFirst(System.Int32,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Inserts value at the head of the list stored at key. If key does not exist and createIfMissing is true, it is created as empty list before performing the push operation. 
            </summary>
            <returns> the length of the list after the push operation.</returns>
            <remarks>http://redis.io/commands/lpush</remarks>
            <remarks>http://redis.io/commands/lpushx</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.AddFirst(System.Int32,System.String,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Inserts value at the head of the list stored at key. If key does not exist and createIfMissing is true, it is created as empty list before performing the push operation. 
            </summary>
            <returns> the length of the list after the push operation.</returns>
            <remarks>http://redis.io/commands/lpush</remarks>
            <remarks>http://redis.io/commands/lpushx</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.AddLast(System.Int32,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Inserts value at the tail of the list stored at key. If key does not exist and createIfMissing is true, it is created as empty list before performing the push operation. 
            </summary>
            <returns> the length of the list after the push operation.</returns>
            <remarks>http://redis.io/commands/rpush</remarks>
            <remarks>http://redis.io/commands/rpushx</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.AddLast(System.Int32,System.String,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Inserts value at the tail of the list stored at key. If key does not exist and createIfMissing is true, it is created as empty list before performing the push operation. 
            </summary>
            <returns> the length of the list after the push operation.</returns>
            <remarks>http://redis.io/commands/rpush</remarks>
            <remarks>http://redis.io/commands/rpushx</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Remove(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Removes the first count occurrences of elements equal to value from the list stored at key.
            </summary>
            <remarks>The count argument influences the operation in the following ways:
            count &gt; 0: Remove elements equal to value moving from head to tail.
            count &lt; 0: Remove elements equal to value moving from tail to head.
            count = 0: Remove all elements equal to value.
            For example, LREM list -2 "hello" will remove the last two occurrences of "hello" in the list stored at list.</remarks>
            <returns>the number of removed elements.</returns>
            <remarks>http://redis.io/commands/lrem</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Remove(System.Int32,System.String,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Removes the first count occurrences of elements equal to value from the list stored at key.
            </summary>
            <remarks>The count argument influences the operation in the following ways:
            count &gt; 0: Remove elements equal to value moving from head to tail.
            count &lt; 0: Remove elements equal to value moving from tail to head.
            count = 0: Remove all elements equal to value.
            For example, LREM list -2 "hello" will remove the last two occurrences of "hello" in the list stored at list.</remarks>
            <returns>the number of removed elements.</returns>
            <remarks>http://redis.io/commands/lrem</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Trim(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Trim an existing list so that it will contain only the specified range of elements specified. Both start and stop are zero-based indexes, where 0 is the first element of the list (the head), 1 the next element and so on.
            start and end can also be negative numbers indicating offsets from the end of the list, where -1 is the last element of the list, -2 the penultimate element and so on.
            </summary>
            <example>For example: LTRIM foobar 0 2 will modify the list stored at foobar so that only the first three elements of the list will remain.</example>
            <remarks>Out of range indexes will not produce an error: if start is larger than the end of the list, or start > end, the result will be an empty list (which causes key to be removed). If end is larger than the end of the list, Redis will treat it like the last element of the list.</remarks>
            <remarks>http://redis.io/commands/ltrim</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Trim(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Trim an existing list so that it will contain only the specified count.
            </summary>
            <remarks>http://redis.io/commands/ltrim</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveLastAndAddFirst(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Atomically returns and removes the last element (tail) of the list stored at source, and pushes the element at the first element (head) of the list stored at destination.
            </summary>
            <string>For example: consider source holding the list a,b,c, and destination holding the list x,y,z. Executing RPOPLPUSH results in source holding a,b and destination holding c,x,y,z.</string>
            <remarks>If source does not exist, the value nil is returned and no operation is performed. If source and destination are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</remarks>
            <returns>the element being popped and pushed.</returns>
            <remarks>http://redis.io/commands/rpoplpush</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RemoveLastAndAddFirstString(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Atomically returns and removes the last element (tail) of the list stored at source, and pushes the element at the first element (head) of the list stored at destination.
            </summary>
            <string>For example: consider source holding the list a,b,c, and destination holding the list x,y,z. Executing RPOPLPUSH results in source holding a,b and destination holding c,x,y,z.</string>
            <remarks>If source does not exist, the value nil is returned and no operation is performed. If source and destination are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</remarks>
            <returns>the element being popped and pushed.</returns>
            <remarks>http://redis.io/commands/rpoplpush</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.RangeString(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the specified elements of the list stored at key. The offsets start and end are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on.
            </summary>
            <remarks>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, -1 is the last element of the list, -2 the penultimate, and so on.</remarks>
            <returns>list of elements in the specified range.</returns>
            <remarks>http://redis.io/commands/lrange</remarks>
        </member>
        <member name="M:BookSleeve.IListCommands.Range(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the specified elements of the list stored at key. The offsets start and end are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on.
            </summary>
            <remarks>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, -1 is the last element of the list, -2 the penultimate, and so on.</remarks>
            <returns>list of elements in the specified range.</returns>
            <remarks>http://redis.io/commands/lrange</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnection.FlushDb(System.Int32)">
            <summary>
            Delete all the keys of the currently selected DB.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.FlushAll">
            <summary>
            Delete all the keys of all the existing databases, not just the currently selected one.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Ping(System.Boolean)">
            <summary>
            This command is often used to test if a connection is still alive, or to measure latency.
            </summary>
            <returns>The latency in milliseconds.</returns>
            <remarks>http://redis.io/commands/ping</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnection.AddToSortedSet(System.Int32,System.String,System.String,System.Double,System.Boolean)">
            <summary>
            See SortedSets.Add
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.AddToSortedSet(System.Int32,System.String,System.Byte[],System.Double,System.Boolean)">
            <summary>
            See SortedSets.Add
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.CardinalityOfSortedSet(System.Int32,System.String,System.Boolean)">
            <summary>
            See SortedSets.GetLength
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementSortedSet(System.Int32,System.String,System.Byte[],System.Double,System.Boolean)">
            <summary>
            See SortedSets.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementSortedSet(System.Int32,System.String,System.String,System.Double,System.Boolean)">
            <summary>
            See SortedSets.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementSortedSet(System.Int32,System.String,System.Double,System.String[],System.Boolean)">
            <summary>
            See SortedSets.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementSortedSet(System.Int32,System.String,System.Double,System.Byte[][],System.Boolean)">
            <summary>
            See SortedSets.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetRangeOfSortedSetDescending(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            See SortedSets.GetRange
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetRangeOfSortedSet(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            See SortedSets.GetRange
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.RemoveFromSortedSetByScore(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            See SortedSets.RemoveRange
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.AddToSet(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Add an item to a set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.AddToSet(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Add an item to a set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.CardinalityOfSet(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the number of items in a set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Intersect(System.Int32,System.String[],System.Boolean)">
            <summary>
            Intersect multiple sets
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Union(System.Int32,System.String[],System.Boolean)">
            <summary>
            Union multiple sets
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IntersectAndStore(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Intersect multiple sets, storing the result
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.UnionAndStore(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Intersect multiple sets, storing the result
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IsMemberOfSet(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Is the given value in the set?
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IsMemberOfSet(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Is the given value in the set?
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetMembersOfSet(System.Int32,System.String,System.Boolean)">
            <summary>
            Gets all members of a set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.RemoveFromSet(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Remove an item from a set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Remove(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes a key from the database.</summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Remove(System.Int32,System.String[],System.Boolean)">
            <summary>
            Removes multiple keys from the database.</summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.ContainsKey(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns if key exists.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Expire(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Set a timeout on key. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is said to be volatile in Redis terminology.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Persist(System.Int32,System.String,System.Boolean)">
            <summary>
            Remove the existing timeout on key.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetKeysSync(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all keys matching pattern.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetKeys(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all keys matching pattern.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Move(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Move key from the currently selected database to the specified destination database.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.RandomKey(System.Int32,System.Boolean)">
            <summary>
            Return a random key from the currently selected database.
            </summary>
            <returns>the random key, or nil when the database is empty.</returns>
            <remarks>http://redis.io/commands/randomkey</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnection.Rename(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Renames a key in the database, overwriting any existing value; the source key must exist and be different to the destination.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.RenameIfNotExists(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Renames a key in the database, overwriting any existing value; the source key must exist and be different to the destination.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.TimeToLive(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the remaining time to live (seconds) of a key that has a timeout.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetHash(System.Int32,System.String,System.Boolean)">
            <summary>
            Enumerate all keys in a hash.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetHashPairs(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all fields and values of the hash stored at key.
            </summary>
            <returns>list of fields and their values stored in the hash, or an empty list when key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementHash(System.Int32,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Increment a field on a hash by an amount (1 by default)
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetHash(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and the value was updated.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetHash(System.Int32,System.String,System.Collections.Generic.Dictionary{System.String,System.Byte[]},System.Boolean)">
            <summary>
            Sets the specified fields to their respective values in the hash stored at key. This command overwrites any existing fields in the hash. If key does not exist, a new key holding a hash is created.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetHash(System.Int32,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and the value was updated.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetHashIfNotExists(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value, only if field does not yet exist. If key does not exist, a new key holding a hash is created. If field already exists, this operation has no effect.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetHashIfNotExists(System.Int32,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Sets field in the hash stored at key to value, only if field does not yet exist. If key does not exist, a new key holding a hash is created. If field already exists, this operation has no effect.
            </summary>
            <returns>1 if field is a new field in the hash and value was set. 0 if field already exists in the hash and no operation was performed.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetFromHashString(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <returns>the value associated with field, or nil when field is not present in the hash or key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetFromHash(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns the value associated with field in the hash stored at key.
            </summary>
            <returns>the value associated with field, or nil when field is not present in the hash or key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetFromHashString(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a nil value is returned.
            </summary>
            <returns>list of values associated with the given fields, in the same order as they are requested.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetFromHash(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Returns the values associated with the specified fields in the hash stored at key. For every field that does not exist in the hash, a nil value is returned.
            </summary>
            <returns>list of values associated with the given fields, in the same order as they are requested.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.RemoveHash(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Removes the specified field from the hash stored at key. Non-existing fields are ignored. Non-existing keys are treated as empty hashes and this command returns 0.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.RemoveHash(System.Int32,System.String,System.String[],System.Boolean)">
            <summary>
            Removes the specified fields from the hash stored at key. Non-existing fields are ignored. Non-existing keys are treated as empty hashes and this command returns 0.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.ContainsHash(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Returns if field is an existing field in the hash stored at key.
            </summary>
            <returns>1 if the hash contains field. 0 if the hash does not contain field, or key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetHashKeys(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all field names in the hash stored at key.
            </summary>
            <returns>list of fields in the hash, or an empty list when key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetHashValues(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns all values in the hash stored at key.
            </summary>
            <returns> list of values in the hash, or an empty list when key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetHashLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Returns the number of fields contained in the hash stored at key.
            </summary>
            <returns>number of fields in the hash, or 0 when key does not exist.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.Get(System.Int32,System.String,System.Boolean)">
            <summary>
            See Strings.Get
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetString(System.Int32,System.String,System.Boolean)">
            <summary>
            See Strings.GetString
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Increment(System.Int32,System.String,System.Boolean)">
            <summary>
            See Strings.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.IncrementBy(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            See Strings.Increment
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.DecrementBy(System.Int32,System.String,System.Int64,System.Boolean)">
            <summary>
            See Strings.Decrement
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Decrement(System.Int32,System.String,System.Boolean)">
            <summary>
            See Strings.Decrement
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Set(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            See Strings.Set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Set(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            See Strings.Set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetIfNotExists(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            See Strings.SetIfNotExists
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetIfNotExists(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            See Strings.SetIfNotExists
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Append(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            See Strings.Append
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Append(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            See Strings.Append
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetWithExpiry(System.Int32,System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            See Strings.Set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetWithExpiry(System.Int32,System.String,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            See Strings.Set
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetStringFromList(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the element at index index in the list stored at key. The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.
            </summary>
            <returns> the requested element, or nil when index is out of range.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetFromList(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the element at index index in the list stored at key. The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.
            </summary>
            <returns> the requested element, or nil when index is out of range.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.ListLength(System.Int32,System.String,System.Boolean)">
            <summary>
            Query the number of items in a list
            </summary>
            <param name="db">The database to operate on</param>
            <param name="key">The key of the list</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The number of items in the list, or 0 if it does not exist</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.LeftPop(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes an item from the start of a list
            </summary>
            <param name="db">The database to operatate on</param>
            <param name="key">The list to remove an item from</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The contents of the item removed, or null if empty</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.RightPop(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes an item from the end of a list
            </summary>
            <param name="db">The database to operatate on</param>
            <param name="key">The list to remove an item from</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The contents of the item removed, or null if empty</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.LeftPush(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Prepend an item to a list
            </summary>
            <param name="db">The database to operate on</param>
            <param name="key">The key of the list</param>
            <param name="value">The item to add</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The number of items now in the list</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.LeftPush(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Prepend an item to a list
            </summary>
            <param name="db">The database to operate on</param>
            <param name="key">The key of the list</param>
            <param name="value">The item to add</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The number of items now in the list</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.RightPush(System.Int32,System.String,System.Byte[],System.Boolean)">
            <summary>
            Append an item to a list
            </summary>
            <param name="db">The database to operate on</param>
            <param name="key">The key of the list</param>
            <param name="value">The item to add</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The number of items now in the list</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.RightPush(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Append an item to a list
            </summary>
            <param name="db">The database to operate on</param>
            <param name="key">The key of the list</param>
            <param name="value">The item to add</param>
            <param name="queueJump">Whether to overtake unsent messages</param>
            <returns>The number of items now in the list</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.PopFromListPushToList(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            See Lists.RemoveLastAndAddFirst
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.ListRange(System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            See Lists.Range
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.#ctor(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Creates a new RedisConnection to a designated server
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.#ctor(BookSleeve.RedisConnection)">
            <summary>
            Creates a child RedisConnection, such as for a RedisTransaction
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.CreateTransaction">
            <summary>
            Allows multiple commands to be buffered and sent to redis as a single atomic unit
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.CreateBatch">
            <summary>
            Allows multiple commands to be buffered and sent to redis collectively, but without any guarantee of atomicity
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SetKeepAlive(System.Int32)">
            <summary>
            Configures an automatic keep-alive PING at a pre-determined interval; this is especially
            useful if CONFIG GET is not available.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetCannotSendMessage">
            <summary>
            The message to supply to callers when rejecting messages
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.CloseAsync(System.Boolean)">
            <summary>
            Closes the connection; either draining the unsent queue (to completion), or abandoning the unsent queue.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.OnInitConnection">
            <summary>
            Called during connection init, but after the AUTH is sent (if needed)
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetOpenSubscriberChannel">
            <summary>
            Creates a pub/sub connection to the same redis server
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.OnDispose">
            <summary>
            Releases any resources associated with the connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetCounters">
            <summary>
            Query usage metrics for this connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetCounters(System.Boolean)">
            <summary>
            Query usage metrics for this connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.GetTimeoutSummary">
            <summary>
            Give some information about the oldest incomplete (but sent) message on the server
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.PromoteToMaster">
            <summary>
            Takes a server out of "slave" mode, to act as a replication master.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.SuspendFlush">
            <summary>
            Temporarily suspends eager-flushing (flushing if the write-queue becomes empty briefly). Buffer-based flushing
            will still occur when the data is full. This is useful if you are performing a large number of
            operations in close duration, and want to avoid packet fragmentation. Note that you MUST call
            ResumeFlush at the end of the operation - preferably using Try/Finally so that flushing is resumed
            even upon error. This method is thread-safe; any number of callers can suspend/resume flushing
            concurrently - eager flushing will resume fully when all callers have called ResumeFlush.
            </summary>
            <remarks>Note that some operations (transaction conditions, etc) require flushing - this will still
            occur even if the buffer is only part full.</remarks>
        </member>
        <member name="M:BookSleeve.RedisConnection.ResumeFlush">
            <summary>
            Resume eager-flushing (flushing if the write-queue becomes empty briefly). See SuspendFlush for
            full usage.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisConnection.Publish(System.String,System.String,System.Boolean)">
            <summary>
            Posts a message to the given channel.
            </summary>
            <returns>the number of clients that received the message.</returns>
        </member>
        <member name="M:BookSleeve.RedisConnection.Publish(System.String,System.Byte[],System.Boolean)">
            <summary>
            Posts a message to the given channel.
            </summary>
            <returns>the number of clients that received the message.</returns>
        </member>
        <member name="P:BookSleeve.RedisConnection.Scripting">
            <summary>
            Commands that apply to Redis scripting (Lua).
            </summary>
            <remarks>http://redis.io/commands#scripting</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Server">
            <summary>
            Commands related to server operation and configuration, rather than data.
            </summary>
            <remarks>http://redis.io/commands#server</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.SortedSets">
            <summary>
            Commands that apply to sorted sets per key. A sorted set keeps a "score"
            per element, and this score is used to order the elements. Duplicates
            are not allowed (typically, the score of the duplicate is added to the
            pre-existing element instead).
            </summary>
            <remarks>http://redis.io/commands#sorted_set</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Sets">
            <summary>
            Commands that apply to sets of items per key; sets
            have no defined order and are strictly unique. Duplicates
            are not allowed (typically, duplicates are silently discarded).
            </summary>
            <remarks>http://redis.io/commands#set</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Keys">
            <summary>
            Generic commands that apply to all/most data structures
            </summary>
            <remarks>http://redis.io/commands#generic</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Hashes">
            <summary>
            Commands that apply to key/sub-key/value tuples, i.e. where
            the item is a dictionary of inner values. This can be useful for
            modelling members of an entity, for example.
            </summary>
            <remarks>http://redis.io/commands#hash</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Strings">
            <summary>
            Commands that apply to key/value pairs, where the value
            can be a string, a BLOB, or interpreted as a number
            </summary>
            <remarks>http://redis.io/commands#string</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.Lists">
            <summary>
            Commands that apply to basic lists of items per key; lists
            preserve insertion order and have no enforced uniqueness (duplicates
            are allowed)
            </summary>
            <remarks>http://redis.io/commands#list</remarks>
        </member>
        <member name="P:BookSleeve.RedisConnection.KeepAliveSeconds">
            <summary>
            How frequently should keep-alives be sent?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnection.LastSentMillisecondsAgo">
            <summary>
            Time (in milliseconds) since the last command was sent
            </summary>
        </member>
        <member name="P:BookSleeve.RedisConnection.OutstandingCount">
            <summary>
            Indicates the number of messages that have not yet been sent to the server.
            </summary>
        </member>
        <member name="T:BookSleeve.RedisConnection.ItemTypes">
            <summary>
            Constants representing the different storage devices in redis
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.None">
            <summary>
            Returned for a key that does not exist
            </summary>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.List">
            <summary>
            Redis Lists are simply lists of strings, sorted by insertion order. It is possible to add elements to a Redis List pushing new elements on the head (on the left) or on the tail (on the right) of the list.
            </summary>
            <remarks>http://redis.io/topics/data-types#lists</remarks>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.String">
            <summary>
            Strings are the most basic kind of Redis value. Redis Strings are binary safe, this means that a Redis string can contain any kind of data, for instance a JPEG image or a serialized Ruby object.
            </summary>
            <remarks>http://redis.io/topics/data-types#strings</remarks>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.Set">
            <summary>
            Redis Sets are an unordered collection of Strings. It is possible to add, remove, and test for existence of members in O(1) (constant time regardless of the number of elements contained inside the Set).
            </summary>
            <remarks>http://redis.io/topics/data-types#sets</remarks>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.SortedSet">
            <summary>
            Redis Sorted Sets are, similarly to Redis Sets, non repeating collections of Strings. The difference is that every member of a Sorted Set is associated with score, that is used in order to take the sorted set ordered, from the smallest to the greatest score.
            </summary>
            <remarks>http://redis.io/topics/data-types#sorted-sets</remarks>
        </member>
        <member name="F:BookSleeve.RedisConnection.ItemTypes.Hash">
            <summary>
            Redis Hashes are maps between string field and string values, so they are the perfect data type to represent objects (for instance Users with a number of fields like name, surname, age, and so forth)
            </summary>
            <remarks>http://redis.io/topics/data-types#hashes</remarks>
        </member>
        <member name="T:BookSleeve.ErrorEventArgs">
            <summary>
            Event data relating to an exception in Redis
            </summary>
        </member>
        <member name="P:BookSleeve.ErrorEventArgs.Exception">
            <summary>
            The exception that occurred
            </summary>
        </member>
        <member name="P:BookSleeve.ErrorEventArgs.Cause">
            <summary>
            What the system was doing when this error occurred
            </summary>
        </member>
        <member name="P:BookSleeve.ErrorEventArgs.IsFatal">
            <summary>
            True if this error has rendered the connection unusable
            </summary>
        </member>
        <member name="T:BookSleeve.RedisAggregate">
            <summary>
            With the AGGREGATE option, it is possible to specify how the results of the union are aggregated. This option defaults to SUM, where the score of an element is summed across the inputs where it exists. When this option is set to either MIN or MAX, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.
            </summary>
        </member>
        <member name="F:BookSleeve.RedisAggregate.Sum">
            <summary>
            The score of an element is summed across the inputs where it exists
            </summary>
        </member>
        <member name="F:BookSleeve.RedisAggregate.Min">
            <summary>
            The resulting set will contain the minimum score of an element across the inputs where it exists
            </summary>
        </member>
        <member name="F:BookSleeve.RedisAggregate.Max">
            <summary>
            The resulting set will contain the maximum score of an element across the inputs where it exists
            </summary>
        </member>
        <member name="T:BookSleeve.ServerType">
            <summary>
            What type of server does this represent
            </summary>
        </member>
        <member name="F:BookSleeve.ServerType.Unknown">
            <summary>
            The server is not yet connected, or is not recognised
            </summary>
        </member>
        <member name="F:BookSleeve.ServerType.Master">
            <summary>
            The server is a master node, suitable for read and write
            </summary>
        </member>
        <member name="F:BookSleeve.ServerType.Slave">
            <summary>
            The server is a replication slave, suitable for read
            </summary>
        </member>
        <member name="F:BookSleeve.ServerType.Sentinel">
            <summary>
            The server is a sentinel, used for anutomated configuration
            and failover
            </summary>
        </member>
        <member name="F:BookSleeve.ServerType.Cluster">
            <summary>
            The server is part of a cluster
            </summary>
        </member>
        <member name="T:BookSleeve.Counters">
            <summary>
            Summary statistics for the RedisConnection
            </summary>
        </member>
        <member name="M:BookSleeve.Counters.ToString">
            <summary>
            Obtain a string representation of the counters
            </summary>
            <returns></returns>
        </member>
        <member name="P:BookSleeve.Counters.KeepAliveSeconds">
            <summary>
            How frequently should keep-alives be sent?
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.LastSentMillisecondsAgo">
            <summary>
            Time (in milliseconds) since the last command was sent
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.LastKeepAliveMillisecondsAgo">
            <summary>
            Time (in milliseconds) since the last command was sent explicitly because of a keep-alive
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.State">
            <summary>
            The state of the server connection
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.SyncCallbacks">
            <summary>
            The number of callbacks executed (total) synchronously
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.AsyncCallbacks">
            <summary>
            The number of callbacks executed (total) asynchronously
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.SyncCallbacksInProgress">
            <summary>
            The number of callbacks executing (currently) synchronously
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.AsyncCallbacksInProgress">
            <summary>
            The number of callbacks executing (currently) asynchronously
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.MessagesSent">
            <summary>
            The number of messages sent to the Redis server
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.MessagesReceived">
            <summary>
            The number of messages received from the Redis server
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.MessagesCancelled">
            <summary>
            The number of queued messages that were withdrawn without being sent
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.Timeouts">
            <summary>
            The number of operations that timed out
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.QueueJumpers">
            <summary>
            The number of operations that were sent ahead of queued items
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.UnsentQueue">
            <summary>
            The number of messages waiting to be sent
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.ErrorMessages">
            <summary>
            The number of error messages received by the server
            </summary>
        </member>
        <member name="P:BookSleeve.Counters.SentQueue">
            <summary>
            The number of messages that have been sent and are waiting for a response</summary>
        </member>
        <member name="P:BookSleeve.Counters.Ping">
            <summary>
            The current time (milliseconds) taken to send a Redis PING command and
            receive a PONG reply
            </summary>
        </member>
        <member name="T:BookSleeve.RedisFeatures">
            <summary>
            Provides basic information about the features available on a particular version of Redis
            </summary>
        </member>
        <member name="M:BookSleeve.RedisFeatures.#ctor(System.Version)">
            <summary>
            Create a new RedisFeatures instance for the given version
            </summary>
        </member>
        <member name="M:BookSleeve.RedisFeatures.ToString">
            <summary>
            Create a string representation of the available features
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.Version">
            <summary>
            The Redis version of the server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.Persist">
            <summary>
            Is the PERSIST operation supported?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.ExpireOverwrite">
            <summary>
            Can EXPIRE be used to set expiration on a key that is already volatile (i.e. has an expiration)?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.HashVaradicDelete">
            <summary>
            Does HDEL support varadic usage?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.StringLength">
            <summary>
            Is STRLEN available?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.StringSetRange">
            <summary>
            Is SETRANGE available?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.PushIfNotExists">
            <summary>
            Is RPUSHX and LPUSHX available?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.SetVaradicAddRemove">
            <summary>
            Does SADD support varadic usage?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.IncrementFloat">
            <summary>
            Does INCRBYFLOAT / HINCRBYFLOAT exist?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.Scripting">
            <summary>
            Does EVAL / EVALSHA / etc exist?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.MultipleRandom">
            <summary>
            Does SRANDMEMBER support "count"?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.Time">
            <summary>
            Does TIME exist?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.BitwiseOperations">
            <summary>
            Does BITOP / BITCOUNT exist?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.ListInsert">
            <summary>
            Is LINSERT available?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.ClientName">
            <summary>
            Is CLIENT SETNAME available?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisFeatures.SetConditional">
            <summary>
            Does SET have the EX|PX|NX|XX extensions?
            </summary>
        </member>
        <member name="T:BookSleeve.RedisBatch">
            <summary>
            Represents a group of operations that will be sent to the server in a group
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.CreateTransaction">
            <summary>
            Not supported, as nested transactions are not available.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.CreateBatch">
            <summary>
            Not supported, as nested batches are not available.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.OnDispose">
            <summary>
            Release any resources held by this transaction/batch.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.Discard">
            <summary>
            Discards any buffered commands; the transaction/batch may subsequently be re-used to buffer additional blocks of commands if needed.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.OnOpening">
            <summary>
            Called before opening a connection
            </summary>
        </member>
        <member name="M:BookSleeve.RedisBatch.Send(System.Boolean,System.Boolean)">
            <summary>
            Send the buffered commands
            </summary>
        </member>
        <member name="P:BookSleeve.RedisBatch.Parent">
            <summary>
            The underlying connection that this batch operates upon
            </summary>
        </member>
        <member name="P:BookSleeve.RedisBatch.Features">
            <summary>
            Features available to the redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisBatch.ServerVersion">
            <summary>
            The version of the connected redis server
            </summary>
        </member>
        <member name="P:BookSleeve.RedisBatch.QuitOnClose">
            <summary>
            Should a QUIT be sent when closing the connection?
            </summary>
        </member>
        <member name="T:BookSleeve.RedisTransaction">
            <summary>
            Represents a group of redis messages that will be sent as a single atomic 
            </summary>
        </member>
        <member name="M:BookSleeve.RedisTransaction.Send(System.Boolean,System.Boolean)">
            <summary>
            Sends all currently buffered commands to the redis server in a single unit; the transaction may subsequently be re-used to buffer additional blocks of commands if needed.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisTransaction.Execute(System.Boolean,System.Object)">
            <summary>
            Sends all currently buffered commands to the redis server in a single unit; the transaction may subsequently be re-used to buffer additional blocks of commands if needed.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisTransaction.AddCondition(BookSleeve.Condition)">
            <summary>
            Add a precondition to be enforced for this transaction
            </summary>
        </member>
        <member name="T:BookSleeve.RedisException">
            <summary>
            A redis-related exception; this could represent a message from the server,
            or a protocol error talking to the server.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisException.#ctor">
            <summary>
            Create a new RedisException
            </summary>
        </member>
        <member name="M:BookSleeve.RedisException.#ctor(System.String)">
            <summary>
            Create a new RedisException
            </summary>
        </member>
        <member name="M:BookSleeve.RedisException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new RedisException
            </summary>
        </member>
        <member name="M:BookSleeve.RedisException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create a new RedisException
            </summary>
        </member>
        <member name="T:BookSleeve.RedisReadonlySlaveException">
            <summary>
            A redis-related exception, where an attempt has been made to change a value on a readonly slave (2.6 or above)
            </summary>
        </member>
        <member name="M:BookSleeve.RedisReadonlySlaveException.#ctor">
            <summary>
            Create a new RedisReadonlySlaveException 
            </summary>
        </member>
        <member name="M:BookSleeve.RedisReadonlySlaveException.#ctor(System.String)">
            <summary>
            Create a new RedisReadonlySlaveException 
            </summary>
        </member>
        <member name="M:BookSleeve.RedisReadonlySlaveException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new RedisReadonlySlaveException 
            </summary>
        </member>
        <member name="T:BookSleeve.RedisSubscriberConnection">
            <summary>
            Provides a Redis connection for listening for (and handling) the subscriber part of a pub/sub implementation.
            Messages are sent using RedisConnection.Publish.
            </summary>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.#ctor(System.String,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Create a new RedisSubscriberConnection instance
            </summary>
            <param name="host">The server to connect to (IP address or name)</param>
            <param name="port">The port on the server to connect to; typically 3679</param>
            <param name="ioTimeout">The timeout to use during IO operations; this can usually be left unlimited</param>
            <param name="password">If the server is secured, the server password (null if not secured)</param>
            <param name="maxUnsent">The maximum number of unsent messages to enqueue before new requests are blocking calls</param>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.OnInitConnection">
            <summary>
            Called during connection init, but after the AUTH is sent (if needed)
            </summary>
            <returns>Whether to release any queued messages</returns>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.OnHandshakeComplete(System.Boolean)">
            <summary>
            Invoked when we have completed the handshake
            </summary>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.Subscribe(System.String,System.Action{System.String,System.Byte[]})">
            <summary>
            Subscribe to a channel
            </summary>
            <param name="key">The channel name</param>
            <param name="handler">A callback to invoke when messages are received on this channel;
            note that the MessageReceived event will also be raised, so this callback can be null.</param>
            <remarks>Channels are server-wide; they are not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.Subscribe(System.String[],System.Action{System.String,System.Byte[]})">
            <summary>
            Subscribe to a set of channels
            </summary>
            <param name="keys">The channel names</param>
            <param name="handler">A callback to invoke when messages are received on these channel;
            note that the MessageReceived event will also be raised, so this callback can be null.</param>
            <remarks>Channels are server-wide; they are not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.PatternSubscribe(System.String,System.Action{System.String,System.Byte[]})">
            <summary>
            Subscribe to a set of pattern (using wildcards, for exmaple "Foo*")
            </summary>
            <param name="key">The pattern to subscribe</param>
            <param name="handler">A callback to invoke when matching messages are received; this can be null
            as the MessageReceived event will also be raised</param>
            <remarks>Channels are server-wide, not per-database</remarks>        
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.PatternSubscribe(System.String[],System.Action{System.String,System.Byte[]})">
            <summary>
            Subscribe to a set of patterns (using wildcards, for exmaple "Foo*")
            </summary>
            <param name="keys">The patterns to subscribe</param>
            <param name="handler">A callback to invoke when matching messages are received; this can be null
            as the MessageReceived event will also be raised</param>
            <remarks>Channels are server-wide, not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.Unsubscribe(System.String)">
            <summary>
            Unsubscribe from a channel
            </summary>
            <param name="key">The channel name</param>
            <remarks>Channels are server-wide; they are not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.Unsubscribe(System.String[])">
            <summary>
            Unsubscribe from a set of channels
            </summary>
            <param name="keys">The channel names</param>
            <remarks>Channels are server-wide; they are not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.PatternUnsubscribe(System.String)">
            <summary>
            Unsubscribe from a pattern (which must match a pattern previously subscribed)
            </summary>
            <param name="key">The pattern to unsubscribe</param>
            <remarks>Channels are server-wide, not per-database</remarks>
        </member>
        <member name="M:BookSleeve.RedisSubscriberConnection.PatternUnsubscribe(System.String[])">
            <summary>
            Unsubscribe from a set of patterns (which must match patterns previously subscribed)
            </summary>
            <param name="keys">The patterns to unsubscribe</param>
            <remarks>Channels are server-wide, not per-database</remarks>
        </member>
        <member name="E:BookSleeve.RedisSubscriberConnection.MessageReceived">
            <summary>
            This event is raised when a message is received on any subscribed channel; this is supplemental
            to any direct callbacks specified.
            </summary>
        </member>
        <member name="P:BookSleeve.RedisSubscriberConnection.QuitOnClose">
            <summary>
            Should a QUIT be sent when closing the connection?
            </summary>
        </member>
        <member name="P:BookSleeve.RedisSubscriberConnection.SubscriptionCount">
            <summary>
            The number of subscriptions currently help by the current connection (as reported by the server during the last
            subsribe/unsubscribe operation)
            </summary>
        </member>
        <member name="T:BookSleeve.ResultCompletionMode">
            <summary>
            Indicates how incoming messages should be completed / dispatched.
            </summary>
        </member>
        <member name="F:BookSleeve.ResultCompletionMode.PreserveOrder">
            <summary>
            Results are always completed synchronously; this guarantees to preserve order, but means that long-running
            continuations may block other operations from completing even when the data is available.
            </summary>
        </member>
        <member name="F:BookSleeve.ResultCompletionMode.Concurrent">
            <summary>
            Results are dispatched asynchronously; no guarantee of order is offered.
            </summary>
        </member>
        <member name="F:BookSleeve.ResultCompletionMode.ConcurrentIfContinuation">
            <summary>
            The system will attempt to determine whether any given operation has a continuation; if it does, it will
            dispatch it concurrently to avoid risk of blocking scenarios; if it does not, it will complete it
            synchronously for performance.
            </summary>
        </member>
        <member name="T:BookSleeve.ShutdownType">
            <summary>
            Indicates the reason that a connection was shut down
            </summary>
        </member>
        <member name="F:BookSleeve.ShutdownType.None">
            <summary>
            The connection is not shut down
            </summary>
        </member>
        <member name="F:BookSleeve.ShutdownType.ClientClosed">
            <summary>
            The connection was closed by the client calling close
            </summary>
        </member>
        <member name="F:BookSleeve.ShutdownType.ClientDisposed">
            <summary>
            The connection was closed by the client being disposed
            </summary>
        </member>
        <member name="F:BookSleeve.ShutdownType.ServerClosed">
            <summary>
            The server closed the connection (EOF)
            </summary>
        </member>
        <member name="F:BookSleeve.ShutdownType.Error">
            <summary>
            The connection was terminated due to an unexpected error
            </summary>
        </member>
        <member name="T:BookSleeve.TaskUtils">
            <summary>
            Utility classes for working safely with tasks
            </summary>
        </member>
        <member name="M:BookSleeve.TaskUtils.SafeAwaitable(System.Threading.Tasks.Task)">
            <summary>
            Create a task wrapper that is safe to use with "await", by avoiding callback-inlining
            </summary>
        </member>
        <member name="M:BookSleeve.TaskUtils.SafeAwaitable``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Create a task wrapper that is safe to use with "await", by avoiding callback-inlining 
            </summary>
        </member>
    </members>
</doc>
